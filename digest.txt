Directory structure:
└── steto/
    ├── build.gradle.kts
    ├── gradle.properties
    ├── settings.gradle.kts
    └── app/
        ├── build.gradle.kts
        ├── proguard-rules.pro
        └── src/
            └── main/
                ├── AndroidManifest.xml
                ├── java/
                │   └── com/
                │       └── example/
                │           └── hearingaidstreamer/
                │               ├── audio/
                │               │   └── LoopbackAudioEngine.kt
                │               ├── permissions/
                │               │   └── PermissionUtils.kt
                │               ├── telecom/
                │               │   ├── CallLifecycleState.kt
                │               │   ├── CallLifecycleStateExtensions.kt
                │               │   ├── CallRouteFormatter.kt
                │               │   ├── HearingAidConnectionService.kt
                │               │   └── TelecomCallManager.kt
                │               └── ui/
                │                   ├── MainActivity.kt
                │                   └── MainViewModel.kt
                └── res/
                    ├── drawable/
                    │   └── ic_launcher_foreground.xml
                    ├── mipmap-anydpi/
                    │   └── ic_launcher.xml
                    ├── mipmap-anydpi-v26/
                    │   └── ic_launcher.xml
                    └── values/
                        ├── colors.xml
                        ├── colors_launcher.xml
                        ├── strings.xml
                        └── themes.xml

================================================
File: build.gradle.kts
================================================
plugins {
    id("com.android.application") version "8.4.2" apply false
    id("org.jetbrains.kotlin.android") version "1.9.24" apply false
}


================================================
File: gradle.properties
================================================
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
android.useAndroidX=true
android.enableJetifier=true
kotlin.code.style=official


================================================
File: settings.gradle.kts
================================================
import org.gradle.api.initialization.resolve.RepositoriesMode

pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "HearingAidStreamer"
include(":app")


================================================
File: app/build.gradle.kts
================================================

plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.example.hearingaidstreamer"
    compileSdk = 34

    defaultConfig {
        applicationId = "com.example.hearingaidstreamer"
        minSdk = 31
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = "17"
    }
    buildFeatures {
        compose = true
    }
    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.14"
    }
    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }
}

dependencies {
    val composeBom = platform("androidx.compose:compose-bom:2024.06.00")
    implementation(composeBom)
    androidTestImplementation(composeBom)

    implementation("androidx.core:core-ktx:1.13.1")
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.7.0")
    implementation("androidx.activity:activity-compose:1.9.0")
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0")
    implementation("androidx.lifecycle:lifecycle-runtime-compose:2.7.0")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.8.1")
    implementation("com.google.android.material:material:1.12.0")
    implementation("androidx.media:media:1.7.0")
    implementation("androidx.core:core-telecom:1.0.0-beta01")

    testImplementation("junit:junit:4.13.2")
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
    androidTestImplementation("androidx.compose.ui:ui-test-junit4")
    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")
}



================================================
File: app/proguard-rules.pro
================================================
# Add project specific ProGuard rules here.
# By default, the flags in this file are appended to flags specified
# in ${sdk.dir}/tools/proguard/proguard-android.txt


================================================
File: app/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />
    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
    <uses-permission android:name="android.permission.BLUETOOTH_SCAN" android:usesPermissionFlags="neverForLocation" />
    <uses-permission android:name="android.permission.BLUETOOTH_ADVERTISE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_MICROPHONE" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.MANAGE_OWN_CALLS" />
    <uses-permission android:name="android.permission.CALL_PHONE" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:supportsRtl="true"
        android:theme="@style/Theme.HearingAidStreamer">

        <activity
            android:name="com.example.hearingaidstreamer.ui.MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <service
            android:name="com.example.hearingaidstreamer.telecom.HearingAidConnectionService"
            android:exported="true"
            android:permission="android.permission.BIND_TELECOM_CONNECTION_SERVICE" />

    </application>

</manifest>


================================================
File: app/src/main/java/com/example/hearingaidstreamer/audio/LoopbackAudioEngine.kt
================================================
package com.example.hearingaidstreamer.audio

import android.media.AudioAttributes
import android.media.AudioFormat
import android.media.AudioRecord
import android.media.AudioTrack
import android.media.MediaRecorder
import java.util.concurrent.atomic.AtomicReference
import kotlin.math.PI
import kotlin.math.abs
import kotlin.math.cos
import kotlin.math.max
import kotlin.math.sin
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.cancelAndJoin
import kotlinx.coroutines.flow.MutableSharedFlow
import kotlinx.coroutines.flow.SharedFlow
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

/**
 * Captures microphone audio, applies the narrow-band filtering pipeline, and replays it while
 * emitting an envelope signal for visualisation.
 */
class LoopbackAudioEngine(
    private val dispatcher: CoroutineDispatcher = Dispatchers.IO
) {

    data class Settings(
        val includeMurmurs: Boolean = false,
        val mainsFrequencyHz: Int = 50,
        val gainMultiplier: Float = 1f,
        val preferredSampleRate: Int = 2000
    )

    private val settingsRef = AtomicReference(Settings())
    private val _envelopeFlow = MutableSharedFlow<Float>(extraBufferCapacity = 512)
    val envelopeFlow: SharedFlow<Float> = _envelopeFlow

    private var job: Job? = null
    private var audioRecord: AudioRecord? = null
    private var audioTrack: AudioTrack? = null

    @Volatile
    private var filtersDirty: Boolean = true

    fun updateSettings(block: (Settings) -> Settings) {
        settingsRef.updateAndGet { current -> block(current) }
        filtersDirty = true
    }

    fun currentSettings(): Settings = settingsRef.get()

    fun start(scope: CoroutineScope) {
        if (job != null) return
        val settings = settingsRef.get()
        val sampleRate = chooseSampleRate(settings.preferredSampleRate)

        val channelConfig = AudioFormat.CHANNEL_IN_MONO
        val audioFormat = AudioFormat.ENCODING_PCM_16BIT
        val minBufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat)
        val bufferSize = max(minBufferSize, sampleRate)

        val record = AudioRecord.Builder()
            .setAudioSource(MediaRecorder.AudioSource.MIC)
            .setAudioFormat(
                AudioFormat.Builder()
                    .setSampleRate(sampleRate)
                    .setEncoding(audioFormat)
                    .setChannelMask(channelConfig)
                    .build()
            )
            .setBufferSizeInBytes(bufferSize * 2)
            .build()

        val track = AudioTrack.Builder()
            .setAudioAttributes(
                AudioAttributes.Builder()
                    .setUsage(AudioAttributes.USAGE_MEDIA)
                    .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                    .build()
            )
            .setAudioFormat(
                AudioFormat.Builder()
                    .setSampleRate(sampleRate)
                    .setEncoding(audioFormat)
                    .setChannelMask(AudioFormat.CHANNEL_OUT_MONO)
                    .build()
            )
            .setBufferSizeInBytes(bufferSize * 2)
            .setTransferMode(AudioTrack.MODE_STREAM)
            .build()

        track.play()
        record.startRecording()

        audioRecord = record
        audioTrack = track

        job = scope.launch(dispatcher) {
            val filterChainFactory = FilterChainFactory(sampleRate)
            var localSettings = settings
            var filterChain = filterChainFactory.create(localSettings)
            var envelope = EnvelopeDetector(sampleRate)

            val buffer = ShortArray(bufferSize)
            val publishWindow = max(sampleRate / 25, 1)
            var accumulator = 0f
            var accumulatorCount = 0

            while (isActive) {
                val read = record.read(buffer, 0, buffer.size)
                if (read <= 0) continue

                val currentSettings = settingsRef.get()
                if (filtersDirty || currentSettings != localSettings) {
                    filterChain = filterChainFactory.create(currentSettings)
                    envelope = EnvelopeDetector(sampleRate)
                    localSettings = currentSettings
                    filtersDirty = false
                }

                var i = 0
                while (i < read) {
                    val raw = buffer[i] / Short.MAX_VALUE.toFloat()
                    val filtered = filterChain.process(raw)
                    val amplified = (filtered * localSettings.gainMultiplier).coerceIn(-1f, 1f)
                    buffer[i] = (amplified * Short.MAX_VALUE.toFloat()).toInt().coerceIn(-32768, 32767).toShort()

                    val env = envelope.process(amplified)
                    accumulator += env
                    accumulatorCount++
                    if (accumulatorCount >= publishWindow) {
                        val avg = accumulator / accumulatorCount
                        _envelopeFlow.tryEmit(avg)
                        accumulator = 0f
                        accumulatorCount = 0
                    }
                    i++
                }

                track.write(buffer, 0, read)
            }
        }
    }

    suspend fun stop() {
        job?.let { existing ->
            withContext(dispatcher) {
                existing.cancelAndJoin()
            }
        }
        job = null

        audioRecord?.apply {
            try {
                stop()
            } catch (_: IllegalStateException) {
            }
            release()
        }
        audioTrack?.apply {
            try {
                stop()
            } catch (_: IllegalStateException) {
            }
            release()
        }
        audioRecord = null
        audioTrack = null
        filtersDirty = true
    }

    private fun chooseSampleRate(preferred: Int): Int {
        val candidates = listOf(preferred, 2000, 4000, 8000, 16000, 44100)
        val channelConfig = AudioFormat.CHANNEL_IN_MONO
        val audioFormat = AudioFormat.ENCODING_PCM_16BIT
        return candidates.firstOrNull { rate ->
            val minBuffer = AudioRecord.getMinBufferSize(rate, channelConfig, audioFormat)
            minBuffer > 0
        } ?: 16000
    }

    private class FilterChainFactory(private val sampleRate: Int) {
        fun create(settings: Settings): FilterChain {
            val cutoffHigh = 20f
            val cutoffLow = if (settings.includeMurmurs) 400f else 150f
            val notchFreq = settings.mainsFrequencyHz.toFloat()
            return FilterChain(sampleRate.toFloat(), cutoffHigh, cutoffLow, notchFreq)
        }
    }

    private class FilterChain(
        private val sampleRate: Float,
        highPassCutoff: Float,
        lowPassCutoff: Float,
        notchFrequency: Float
    ) {
        private val hpSections = arrayOf(
            Biquad.highPass(sampleRate, highPassCutoff, Q1),
            Biquad.highPass(sampleRate, highPassCutoff, Q2)
        )
        private val notch = Biquad.notch(sampleRate, notchFrequency, 35f)
        private val lpSections = arrayOf(
            Biquad.lowPass(sampleRate, lowPassCutoff, Q1),
            Biquad.lowPass(sampleRate, lowPassCutoff, Q2)
        )

        fun process(sample: Float): Float {
            var value = sample
            hpSections.forEach { value = it.process(value) }
            value = notch.process(value)
            lpSections.forEach { value = it.process(value) }
            return value
        }

        companion object {
            private const val Q1 = 0.5411961f
            private const val Q2 = 1.306563f
        }
    }

    private class EnvelopeDetector(sampleRate: Int) {
        private val lowPass = Biquad.lowPass(sampleRate.toFloat(), 8f, 0.707f)
        fun process(sample: Float): Float {
            val rectified = abs(sample)
            return lowPass.process(rectified)
        }
    }

    private class Biquad private constructor(
        private var sampleRate: Float,
        private var frequency: Float,
        private var q: Float,
        private val type: Type
    ) {
        private var a1 = 0f
        private var a2 = 0f
        private var b0 = 0f
        private var b1 = 0f
        private var b2 = 0f
        private var z1 = 0f
        private var z2 = 0f

        init {
            recalculate()
        }

        fun process(input: Float): Float {
            val output = b0 * input + z1
            z1 = b1 * input - a1 * output + z2
            z2 = b2 * input - a2 * output
            return output
        }

        private fun recalculate() {
            val omega = 2f * PI.toFloat() * frequency / sampleRate
            val sin = sin(omega)
            val cos = cos(omega)
            val alpha = sin / (2f * q)
            when (type) {
                Type.LOW_PASS -> {
                    val b0Raw = (1f - cos) / 2f
                    val b1Raw = 1f - cos
                    val b2Raw = (1f - cos) / 2f
                    val a0 = 1f + alpha
                    val a1Raw = -2f * cos
                    val a2Raw = 1f - alpha
                    setCoefficients(b0Raw, b1Raw, b2Raw, a0, a1Raw, a2Raw)
                }
                Type.HIGH_PASS -> {
                    val b0Raw = (1f + cos) / 2f
                    val b1Raw = -(1f + cos)
                    val b2Raw = (1f + cos) / 2f
                    val a0 = 1f + alpha
                    val a1Raw = -2f * cos
                    val a2Raw = 1f - alpha
                    setCoefficients(b0Raw, b1Raw, b2Raw, a0, a1Raw, a2Raw)
                }
                Type.NOTCH -> {
                    val b0Raw = 1f
                    val b1Raw = -2f * cos
                    val b2Raw = 1f
                    val a0 = 1f + alpha
                    val a1Raw = -2f * cos
                    val a2Raw = 1f - alpha
                    setCoefficients(b0Raw, b1Raw, b2Raw, a0, a1Raw, a2Raw)
                }
            }
        }

        private fun setCoefficients(b0Raw: Float, b1Raw: Float, b2Raw: Float, a0: Float, a1Raw: Float, a2Raw: Float) {
            val invA0 = 1f / a0
            b0 = b0Raw * invA0
            b1 = b1Raw * invA0
            b2 = b2Raw * invA0
            a1 = a1Raw * invA0
            a2 = a2Raw * invA0
        }

        companion object {
            fun lowPass(sampleRate: Float, frequency: Float, q: Float) = Biquad(sampleRate, frequency, q, Type.LOW_PASS)
            fun highPass(sampleRate: Float, frequency: Float, q: Float) = Biquad(sampleRate, frequency, q, Type.HIGH_PASS)
            fun notch(sampleRate: Float, frequency: Float, q: Float) = Biquad(sampleRate, frequency, q, Type.NOTCH)
        }

        private enum class Type { LOW_PASS, HIGH_PASS, NOTCH }
    }
}



================================================
File: app/src/main/java/com/example/hearingaidstreamer/permissions/PermissionUtils.kt
================================================
package com.example.hearingaidstreamer.permissions

import android.content.Context
import android.content.pm.PackageManager
import androidx.core.content.ContextCompat

fun missingPermissions(context: Context, permissions: Collection<String>): List<String> {
    return permissions.filter { permission ->
        ContextCompat.checkSelfPermission(context, permission) != PackageManager.PERMISSION_GRANTED
    }
}


================================================
File: app/src/main/java/com/example/hearingaidstreamer/telecom/CallLifecycleState.kt
================================================
package com.example.hearingaidstreamer.telecom

sealed interface CallLifecycleState {
    data object Idle : CallLifecycleState
    data object Connecting : CallLifecycleState
    data object Active : CallLifecycleState
    data object Ending : CallLifecycleState
    data class Error(val message: String) : CallLifecycleState
}


================================================
File: app/src/main/java/com/example/hearingaidstreamer/telecom/CallLifecycleStateExtensions.kt
================================================
package com.example.hearingaidstreamer.telecom

import android.content.Context
import com.example.hearingaidstreamer.R

fun CallLifecycleState.readableStatus(context: Context): String = when (this) {
    CallLifecycleState.Idle -> context.getString(R.string.call_idle)
    CallLifecycleState.Connecting -> context.getString(R.string.call_connecting)
    CallLifecycleState.Active -> context.getString(R.string.call_active)
    CallLifecycleState.Ending -> context.getString(R.string.call_ending)
    is CallLifecycleState.Error -> context.getString(R.string.call_error_prefix, message)
}


================================================
File: app/src/main/java/com/example/hearingaidstreamer/telecom/CallRouteFormatter.kt
================================================
package com.example.hearingaidstreamer.telecom

import android.content.Context
import android.telecom.CallEndpoint
import com.example.hearingaidstreamer.R

object CallRouteFormatter {
    fun label(context: Context, endpoint: CallEndpoint): String {
        return when (endpoint.endpointType) {
            CallEndpoint.TYPE_BLUETOOTH -> context.getString(R.string.bluetooth_route)
            CallEndpoint.TYPE_SPEAKER -> context.getString(R.string.speaker_route)
            CallEndpoint.TYPE_STREAMING -> context.getString(R.string.hearing_aid_route)
            else -> endpoint.endpointName.toString()
        }
    }
}


================================================
File: app/src/main/java/com/example/hearingaidstreamer/telecom/HearingAidConnectionService.kt
================================================
package com.example.hearingaidstreamer.telecom

import android.telecom.Connection
import android.telecom.ConnectionRequest
import android.telecom.ConnectionService
import android.telecom.DisconnectCause
import android.telecom.PhoneAccountHandle

/**
 * Minimal self-managed connection service required so that Telecom accepts the self-managed
 * phone account registration. All media handling is coordinated via [TelecomCallManager].
 */
class HearingAidConnectionService : ConnectionService() {

    override fun onCreateOutgoingConnection(
        connectionManagerPhoneAccount: PhoneAccountHandle?,
        request: ConnectionRequest
    ): Connection {
        return createStubConnection()
    }

    override fun onCreateIncomingConnection(
        connectionManagerPhoneAccount: PhoneAccountHandle?,
        request: ConnectionRequest
    ): Connection {
        return createStubConnection()
    }

    private fun createStubConnection(): Connection {
        return Connection().apply {
            setConnectionCapabilities(Connection.CAPABILITY_SELF_MANAGED)
            setDisconnected(DisconnectCause(DisconnectCause.LOCAL))
            destroy()
        }
    }
}


================================================
File: app/src/main/java/com/example/hearingaidstreamer/telecom/TelecomCallManager.kt
================================================
package com.example.hearingaidstreamer.telecom

import android.content.ComponentName
import android.content.Context
import android.net.Uri
import android.os.Build
import android.os.OutcomeReceiver
import android.telecom.CallAttributes
import android.telecom.CallControl
import android.telecom.CallControlCallback
import android.telecom.CallEndpoint
import android.telecom.CallEventCallback
import android.telecom.CallException
import android.telecom.CallStreamingService
import android.telecom.DisconnectCause
import android.telecom.PhoneAccount
import android.telecom.PhoneAccountHandle
import android.telecom.TelecomManager
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.core.content.ContextCompat
import com.example.hearingaidstreamer.R
import com.example.hearingaidstreamer.audio.LoopbackAudioEngine
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.concurrent.Executor
import java.util.function.Consumer

/**
 * Coordinates a self-managed VoIP call using the platform Telecom APIs (Android 14+).
 */
@RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
class TelecomCallManager(
    private val context: Context,
    private val scope: CoroutineScope,
    private val audioEngine: LoopbackAudioEngine
) {

    private val telecomManager: TelecomManager =
        context.getSystemService(TelecomManager::class.java)
            ?: throw IllegalStateException("TelecomManager not available")

    private val phoneAccountHandle = PhoneAccountHandle(
        ComponentName(context, HearingAidConnectionService::class.java),
        PHONE_ACCOUNT_ID
    )

    private val mainExecutor: Executor = ContextCompat.getMainExecutor(context)

    private val _state = MutableStateFlow<CallLifecycleState>(CallLifecycleState.Idle)
    val state: StateFlow<CallLifecycleState> = _state

    private val _availableEndpoints = MutableStateFlow<List<CallEndpoint>>(emptyList())
    val availableEndpoints: StateFlow<List<CallEndpoint>> = _availableEndpoints

    private val _activeEndpoint = MutableStateFlow<CallEndpoint?>(null)
    val activeEndpoint: StateFlow<CallEndpoint?> = _activeEndpoint

    private var callControl: CallControl? = null

    private val controlCallback = object : CallControlCallback {
        override fun onSetActive(wasCompleted: Consumer<Boolean>) {
            wasCompleted.accept(true)
        }

        override fun onSetInactive(wasCompleted: Consumer<Boolean>) {
            scope.launch { audioEngine.stop() }
            _state.value = CallLifecycleState.Ending
            wasCompleted.accept(true)
        }

        override fun onAnswer(videoState: Int, wasCompleted: Consumer<Boolean>) {
            wasCompleted.accept(true)
        }

        override fun onDisconnect(disconnectCause: DisconnectCause, wasCompleted: Consumer<Boolean>) {
            scope.launch {
                stopCallInternal(disconnectCause)
                wasCompleted.accept(true)
            }
        }

        override fun onCallStreamingStarted(wasCompleted: Consumer<Boolean>) {
            scope.launch {
                audioEngine.start(scope)
                _state.value = CallLifecycleState.Active
                wasCompleted.accept(true)
            }
        }
    }

    private val eventCallback = object : CallEventCallback {
        override fun onCallEndpointChanged(newCallEndpoint: CallEndpoint) {
            _activeEndpoint.value = newCallEndpoint
        }

        override fun onAvailableCallEndpointsChanged(availableEndpoints: List<CallEndpoint>) {
            _availableEndpoints.value = availableEndpoints
        }

        override fun onMuteStateChanged(isMuted: Boolean) {
            // Hook for future mute UI; no-op for now.
        }

        override fun onCallStreamingFailed(reason: Int) {
            val message = when (reason) {
                CallStreamingService.STREAMING_FAILED_ALREADY_STREAMING ->
                    context.getString(R.string.call_streaming_failed_in_use)
                CallStreamingService.STREAMING_FAILED_NO_SENDER,
                CallStreamingService.STREAMING_FAILED_SENDER_BINDING_ERROR ->
                    context.getString(R.string.call_streaming_failed_no_sender)
                else -> context.getString(R.string.call_streaming_failed_generic)
            }
            _state.value = CallLifecycleState.Error(message)
        }

        override fun onEvent(event: String, extras: android.os.Bundle) {
            // Reserved for companion surfaces (car, wearable, etc.)
        }
    }

    init {
        ensurePhoneAccountRegistered()
    }

    fun startCall() {
        if (callControl != null) return
        _state.value = CallLifecycleState.Connecting

        val handle = Uri.fromParts("voip", "hearing_stream", null)
        val callAttributes = CallAttributes.Builder(
            phoneAccountHandle,
            CallAttributes.DIRECTION_OUTGOING,
            context.getString(R.string.app_name),
            handle
        )
            .setCallType(CallAttributes.AUDIO_CALL)
            .setCallCapabilities(CallAttributes.SUPPORTS_SET_INACTIVE or CallAttributes.SUPPORTS_STREAM)
            .build()

        telecomManager.addCall(
            callAttributes,
            mainExecutor,
            object : OutcomeReceiver<CallControl, CallException> {
                override fun onResult(result: CallControl) {
                    callControl = result
                    requestActiveAndStreaming(result)
                }

                override fun onError(error: CallException) {
                    _state.value = CallLifecycleState.Error(error.message ?: "Call setup failed")
                }
            },
            controlCallback,
            eventCallback
        )
    }

    fun stopCall() {
        val control = callControl ?: return
        val disconnectCause = DisconnectCause(DisconnectCause.LOCAL)
        control.disconnect(disconnectCause, mainExecutor, outcomeReceiver("disconnect"))
        scope.launch { stopCallInternal(disconnectCause) }
    }

    fun requestEndpointChange(endpoint: CallEndpoint) {
        val control = callControl ?: return
        control.requestCallEndpointChange(endpoint, mainExecutor, outcomeReceiver("endpoint"))
    }

    private fun requestActiveAndStreaming(control: CallControl) {
        control.setActive(mainExecutor, outcomeReceiver("setActive") { success ->
            if (success) {
                control.startCallStreaming(mainExecutor, outcomeReceiver("startStreaming") { streaming ->
                    if (!streaming) {
                        _state.value = CallLifecycleState.Error(context.getString(R.string.call_streaming_failed_generic))
                    }
                })
            } else {
                _state.value = CallLifecycleState.Error(context.getString(R.string.call_activation_failed))
            }
        })
    }

    private suspend fun stopCallInternal(disconnectCause: DisconnectCause) {
        audioEngine.stop()
        withContext(Dispatchers.Main) {
            _state.value = CallLifecycleState.Idle
            _availableEndpoints.value = emptyList()
            _activeEndpoint.value = null
            callControl = null
        }
    }

    private fun outcomeReceiver(
        tag: String,
        onResult: ((Boolean) -> Unit)? = null
    ): OutcomeReceiver<Void, CallException> {
        return object : OutcomeReceiver<Void, CallException> {
            override fun onResult(result: Void?) {
                onResult?.invoke(true)
            }

            override fun onError(error: CallException) {
                Log.e(TAG, "$tag failed", error)
                onResult?.invoke(false)
            }
        }
    }

    private fun ensurePhoneAccountRegistered() {
        val existing = telecomManager.getPhoneAccount(phoneAccountHandle)
        if (existing != null) return

        val phoneAccount = PhoneAccount.Builder(
            phoneAccountHandle,
            context.getString(R.string.app_name)
        )
            .setCapabilities(PhoneAccount.CAPABILITY_SELF_MANAGED)
            .setShortDescription(context.getString(R.string.app_name))
            .setSupportedUriSchemes(listOf("voip", PhoneAccount.SCHEME_SIP))
            .build()

        telecomManager.registerPhoneAccount(phoneAccount)
    }

    companion object {
        private const val TAG = "TelecomCallManager"
        private const val PHONE_ACCOUNT_ID = "hearing_aid_streamer_account"
    }
}


================================================
File: app/src/main/java/com/example/hearingaidstreamer/ui/MainActivity.kt
================================================
package com.example.hearingaidstreamer.ui

import android.Manifest
import android.os.Build
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.FilterChip
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Slider
import androidx.compose.material3.Surface
import androidx.compose.material3.Switch
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.StrokeCap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.example.hearingaidstreamer.permissions.missingPermissions
import com.example.hearingaidstreamer.telecom.CallLifecycleState
import com.example.hearingaidstreamer.telecom.CallRouteFormatter
import com.example.hearingaidstreamer.telecom.readableStatus
import kotlinx.coroutines.flow.StateFlow

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MaterialTheme {
                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {
                    val context = this@MainActivity
                    val viewModel: MainViewModel = viewModel(factory = MainViewModel.factory(context))
                    val callState by viewModel.callState.collectAsStateWithLifecycleCompat()
                    val endpoints by viewModel.availableEndpoints.collectAsStateWithLifecycleCompat()
                    val activeEndpoint by viewModel.activeEndpoint.collectAsStateWithLifecycleCompat()
                    val waveform by viewModel.waveform.collectAsStateWithLifecycleCompat()
                    val gainPosition by viewModel.gainPosition.collectAsStateWithLifecycleCompat()
                    val includeMurmurs by viewModel.includeMurmurs.collectAsStateWithLifecycleCompat()
                    val mainsFrequency by viewModel.mainsFrequency.collectAsStateWithLifecycleCompat()

                    val requiredPermissions = remember {
                        buildList {
                            add(Manifest.permission.RECORD_AUDIO)
                            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                                add(Manifest.permission.BLUETOOTH_CONNECT)
                                add(Manifest.permission.BLUETOOTH_SCAN)
                            }
                            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                                add(Manifest.permission.POST_NOTIFICATIONS)
                            }
                            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
                                add(Manifest.permission.MANAGE_OWN_CALLS)
                            }
                        }
                    }

                    var missing by rememberSaveable { mutableStateOf(missingPermissions(context, requiredPermissions)) }

                    LaunchedEffect(requiredPermissions) {
                        missing = missingPermissions(context, requiredPermissions)
                    }

                    val permissionLauncher = androidx.activity.compose.rememberLauncherForActivityResult(
                        contract = ActivityResultContracts.RequestMultiplePermissions()
                    ) { result ->
                        val stillMissing = missingPermissions(context, requiredPermissions)
                        missing = stillMissing
                        val granted = result.values.all { it }
                        if (granted && stillMissing.isEmpty()) {
                            viewModel.startCall()
                        }
                    }

                    MainScreen(
                        state = callState,
                        waveform = waveform,
                        gainPosition = gainPosition,
                        includeMurmurs = includeMurmurs,
                        mainsFrequency = mainsFrequency,
                        endpoints = endpoints,
                        activeEndpoint = activeEndpoint,
                        missingPermissions = missing,
                        onRequestPermissions = {
                            permissionLauncher.launch(requiredPermissions.toTypedArray())
                        },
                        onStart = viewModel::startCall,
                        onStop = viewModel::stopCall,
                        onSelectEndpoint = viewModel::requestEndpoint,
                        onGainChanged = viewModel::onGainPositionChanged,
                        onIncludeMurmursChanged = viewModel::onIncludeMurmursChanged,
                        onMainsFrequencyChanged = viewModel::onMainsFrequencyChanged
                    )
                }
            }
        }
    }
}

@Composable
private fun MainScreen(
    state: CallLifecycleState,
    waveform: List<Float>,
    gainPosition: Float,
    includeMurmurs: Boolean,
    mainsFrequency: Int,
    endpoints: List<android.telecom.CallEndpoint>,
    activeEndpoint: android.telecom.CallEndpoint?,
    missingPermissions: List<String>,
    onRequestPermissions: () -> Unit,
    onStart: () -> Unit,
    onStop: () -> Unit,
    onSelectEndpoint: (android.telecom.CallEndpoint) -> Unit,
    onGainChanged: (Float) -> Unit,
    onIncludeMurmursChanged: (Boolean) -> Unit,
    onMainsFrequencyChanged: (Int) -> Unit
) {
    val context = LocalContext.current
    Scaffold { paddingValues ->
        Column(
            modifier = Modifier
                .padding(paddingValues)
                .padding(24.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Text(
                text = state.readableStatus(context),
                style = MaterialTheme.typography.headlineSmall,
                fontWeight = FontWeight.SemiBold
            )

            when (state) {
                is CallLifecycleState.Connecting -> CircularProgressIndicator()
                is CallLifecycleState.Error -> Text(
                    text = state.message,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.error
                )
                else -> Unit
            }

            WaveformCard(samples = waveform, modifier = Modifier.fillMaxWidth().height(160.dp))

            GainSlider(gainPosition = gainPosition, onGainChanged = onGainChanged)

            MainsAndMurmurControls(
                includeMurmurs = includeMurmurs,
                mainsFrequency = mainsFrequency,
                onIncludeMurmursChanged = onIncludeMurmursChanged,
                onMainsFrequencyChanged = onMainsFrequencyChanged
            )

            if (missingPermissions.isNotEmpty()) {
                PermissionCard(missingPermissions = missingPermissions, onRequestPermissions = onRequestPermissions)
            } else {
                val canStart = state is CallLifecycleState.Idle || state is CallLifecycleState.Error
                Button(onClick = onStart, enabled = canStart) {
                    Text(text = context.getString(com.example.hearingaidstreamer.R.string.start_stream))
                }

                val canStop = state is CallLifecycleState.Active || state is CallLifecycleState.Connecting || state is CallLifecycleState.Ending
                Button(onClick = onStop, enabled = canStop) {
                    Text(text = context.getString(com.example.hearingaidstreamer.R.string.stop_stream))
                }

                if (endpoints.isNotEmpty()) {
                    Text(
                        text = context.getString(com.example.hearingaidstreamer.R.string.request_route),
                        style = MaterialTheme.typography.titleMedium
                    )

                    LazyRow(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
                        items(endpoints, key = { it.identifier }) { endpoint ->
                            val selected = activeEndpoint?.identifier == endpoint.identifier
                            FilterChip(
                                selected = selected,
                                onClick = { onSelectEndpoint(endpoint) },
                                label = { Text(CallRouteFormatter.label(context, endpoint)) }
                            )
                        }
                    }

                    activeEndpoint?.let { endpoint ->
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            text = context.getString(
                                com.example.hearingaidstreamer.R.string.active_route,
                                CallRouteFormatter.label(context, endpoint)
                            ),
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun WaveformCard(samples: List<Float>, modifier: Modifier = Modifier) {
    Card(modifier = modifier) {
        Canvas(modifier = Modifier.fillMaxSize().padding(horizontal = 12.dp, vertical = 8.dp)) {
            if (samples.isEmpty()) return@Canvas
            val maxAmp = samples.maxOrNull()?.coerceAtLeast(1e-3f) ?: 1e-3f
            val stepX = if (samples.size > 1) size.width / (samples.size - 1f) else size.width
            val path = Path()
            samples.forEachIndexed { index, value ->
                val norm = (value / maxAmp).coerceIn(0f, 1f)
                val x = index * stepX
                val y = size.height - (norm * size.height)
                if (index == 0) path.moveTo(x, y) else path.lineTo(x, y)
            }
            drawPath(
                path = path,
                color = MaterialTheme.colorScheme.primary,
                style = Stroke(width = 2.dp.toPx(), cap = StrokeCap.Round)
            )
        }
    }
}

@Composable
private fun GainSlider(gainPosition: Float, onGainChanged: (Float) -> Unit) {
    Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
        Text(
            text = "Gain ${MainViewModel.gainLabel(gainPosition)}",
            style = MaterialTheme.typography.titleMedium
        )
        Slider(
            value = gainPosition,
            onValueChange = onGainChanged,
            valueRange = 0f..1f
        )
    }
}

@Composable
private fun MainsAndMurmurControls(
    includeMurmurs: Boolean,
    mainsFrequency: Int,
    onIncludeMurmursChanged: (Boolean) -> Unit,
    onMainsFrequencyChanged: (Int) -> Unit
) {
    Column(verticalArrangement = Arrangement.spacedBy(8.dp)) {
        Text(text = "Acoustic emphasis", style = MaterialTheme.typography.titleMedium)
        Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(12.dp)) {
            Text(text = "Include murmurs")
            Switch(checked = includeMurmurs, onCheckedChange = onIncludeMurmursChanged)
        }
        Text(text = "Mains frequency", style = MaterialTheme.typography.labelLarge)
        Row(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
            listOf(50, 60).forEach { value ->
                FilterChip(
                    selected = value == mainsFrequency,
                    onClick = { onMainsFrequencyChanged(value) },
                    label = { Text("${value} Hz") }
                )
            }
        }
    }
}

@Composable
private fun PermissionCard(missingPermissions: List<String>, onRequestPermissions: () -> Unit) {
    val context = LocalContext.current
    Card(modifier = Modifier.padding(vertical = 8.dp)) {
        Column(modifier = Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
            missingPermissions.mapNotNull { permission ->
                when (permission) {
                    Manifest.permission.RECORD_AUDIO -> context.getString(com.example.hearingaidstreamer.R.string.microphone_permission_rationale)
                    Manifest.permission.BLUETOOTH_CONNECT,
                    Manifest.permission.BLUETOOTH_SCAN -> context.getString(com.example.hearingaidstreamer.R.string.bluetooth_permission_rationale)
                    Manifest.permission.MANAGE_OWN_CALLS -> context.getString(com.example.hearingaidstreamer.R.string.call_permission_rationale)
                    Manifest.permission.POST_NOTIFICATIONS -> context.getString(com.example.hearingaidstreamer.R.string.notification_permission_rationale)
                    else -> null
                }
            }.distinct().forEach { rationale ->
                Text(text = rationale, style = MaterialTheme.typography.bodyMedium)
            }
            Button(onClick = onRequestPermissions) {
                Text(text = context.getString(com.example.hearingaidstreamer.R.string.grant_permissions))
            }
        }
    }
}

@Composable
private fun <T> StateFlow<T>.collectAsStateWithLifecycleCompat(): androidx.compose.runtime.State<T> {
    val stateFlow = this
    val initialValue = remember(stateFlow) { stateFlow.value }
    val state = remember { mutableStateOf(initialValue) }
    LaunchedEffect(stateFlow) {
        stateFlow.collect { value -> state.value = value }
    }
    return state
}



================================================
File: app/src/main/java/com/example/hearingaidstreamer/ui/MainViewModel.kt
================================================
package com.example.hearingaidstreamer.ui

import android.content.Context
import android.os.Build
import android.telecom.CallEndpoint
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.example.hearingaidstreamer.R
import com.example.hearingaidstreamer.audio.LoopbackAudioEngine
import com.example.hearingaidstreamer.media.StreamMediaSessionController
import com.example.hearingaidstreamer.telecom.CallLifecycleState
import com.example.hearingaidstreamer.telecom.TelecomCallManager
import java.util.ArrayDeque
import java.util.Locale
import kotlin.math.exp
import kotlin.math.ln
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch

class MainViewModel(private val appContext: Context) : ViewModel() {

    private val audioEngine = LoopbackAudioEngine()

    private val mediaController: StreamMediaSessionController?
    private val callManager: TelecomCallManager?

    private val _gainPosition = MutableStateFlow(0f)
    val gainPosition: StateFlow<Float> = _gainPosition.asStateFlow()

    private val _includeMurmurs = MutableStateFlow(false)
    val includeMurmurs: StateFlow<Boolean> = _includeMurmurs.asStateFlow()

    private val _mainsFrequency = MutableStateFlow(50)
    val mainsFrequency: StateFlow<Int> = _mainsFrequency.asStateFlow()

    private val amplitudeHistory = ArrayDeque<Float>()
    private val _waveform = MutableStateFlow<List<Float>>(emptyList())
    val waveform: StateFlow<List<Float>> = _waveform.asStateFlow()

    private val unsupportedState = MutableStateFlow<CallLifecycleState>(
        CallLifecycleState.Error(appContext.getString(R.string.unsupported_version))
    )

    private val emptyEndpoints = MutableStateFlow<List<CallEndpoint>>(emptyList())
    private val nullEndpoint = MutableStateFlow<CallEndpoint?>(null)

    val callState: StateFlow<CallLifecycleState>
    val availableEndpoints: StateFlow<List<CallEndpoint>>
    val activeEndpoint: StateFlow<CallEndpoint?>

    init {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
            var createdManager: TelecomCallManager? = null
            val controller = StreamMediaSessionController(appContext, viewModelScope, audioEngine) {
                createdManager?.stopCall()
            }
            val manager = TelecomCallManager(appContext, viewModelScope, controller)
            createdManager = manager
            mediaController = controller
            callManager = manager
        } else {
            mediaController = null
            callManager = null
        }

        callState = callManager?.state ?: unsupportedState
        availableEndpoints = callManager?.availableEndpoints ?: emptyEndpoints
        activeEndpoint = callManager?.activeEndpoint ?: nullEndpoint

        // Apply initial settings to the audio engine
        audioEngine.updateSettings { current ->
            current.copy(
                includeMurmurs = _includeMurmurs.value,
                mainsFrequencyHz = _mainsFrequency.value,
                gainMultiplier = sliderToGain(_gainPosition.value)
            )
        }

        viewModelScope.launch {
            audioEngine.envelopeFlow.collect { value ->
                appendAmplitude(value)
            }
        }
    }

    fun startCall() {
        callManager?.startCall()
    }

    fun stopCall() {
        callManager?.stopCall()
    }

    fun requestEndpoint(endpoint: CallEndpoint) {
        callManager?.requestEndpointChange(endpoint)
    }

    fun onGainPositionChanged(position: Float) {
        _gainPosition.value = position
        audioEngine.updateSettings { current -> current.copy(gainMultiplier = sliderToGain(position)) }
    }

    fun onIncludeMurmursChanged(enabled: Boolean) {
        _includeMurmurs.value = enabled
        audioEngine.updateSettings { current -> current.copy(includeMurmurs = enabled) }
    }

    fun onMainsFrequencyChanged(frequency: Int) {
        _mainsFrequency.value = frequency
        audioEngine.updateSettings { current -> current.copy(mainsFrequencyHz = frequency) }
    }

    override fun onCleared() {
        callManager?.stopCall()
        mediaController?.let { controller ->
            viewModelScope.launch { controller.release() }
        }
        super.onCleared()
    }

    private fun appendAmplitude(sample: Float) {
        val capped = sample.coerceIn(0f, 1f)
        amplitudeHistory.addLast(capped)
        while (amplitudeHistory.size > HISTORY_CAPACITY) {
            amplitudeHistory.removeFirst()
        }
        _waveform.value = amplitudeHistory.toList()
    }

    companion object {
        private const val HISTORY_SECONDS = 60
        private const val SAMPLES_PER_SECOND = 25
        private const val HISTORY_CAPACITY = HISTORY_SECONDS * SAMPLES_PER_SECOND

        fun sliderToGain(position: Float): Float {
            val clamped = position.coerceIn(0f, 1f)
            return exp(ln(50f) * clamped)
        }

        fun gainLabel(position: Float): String = String.format(Locale.US, "×%.1f", sliderToGain(position))

        fun factory(appContext: Context): ViewModelProvider.Factory = object : ViewModelProvider.Factory {
            override fun <T : ViewModel> create(modelClass: Class<T>): T {
                require(modelClass.isAssignableFrom(MainViewModel::class.java))
                @Suppress("UNCHECKED_CAST")
                return MainViewModel(appContext.applicationContext) as T
            }
        }
    }
}



================================================
File: app/src/main/res/drawable/ic_launcher_foreground.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <group android:translationX="27" android:translationY="27">
        <path
            android:fillColor="#FFFFFF"
            android:pathData="M27,54c-6.075,0 -11,-4.925 -11,-11s4.925,-11 11,-11 11,4.925 11,11 -4.925,11 -11,11z"/>
        <path
            android:fillColor="#1E88E5"
            android:pathData="M27,45c-1.657,0 -3,-1.343 -3,-3s1.343,-3 3,-3 3,1.343 3,3 -1.343,3 -3,3z"/>
        <path
            android:fillColor="#1E88E5"
            android:pathData="M13,25h28v6h-28z"/>
        <path
            android:fillColor="#FFFFFF"
            android:pathData="M13,28c0,-8.837 7.163,-16 16,-16s16,7.163 16,16h-6c0,-5.523 -4.477,-10 -10,-10s-10,4.477 -10,10z"/>
    </group>
</vector>


================================================
File: app/src/main/res/mipmap-anydpi/ic_launcher.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>


================================================
File: app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>


================================================
File: app/src/main/res/values/colors.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="md_theme_light_primary">#6750A4</color>
    <color name="md_theme_light_onPrimary">#FFFFFF</color>
    <color name="md_theme_light_secondary">#625B71</color>
    <color name="md_theme_light_onSecondary">#FFFFFF</color>
</resources>


================================================
File: app/src/main/res/values/colors_launcher.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_background">#1E88E5</color>
</resources>


================================================
File: app/src/main/res/values/strings.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">Steto Hearing Aid Streamer</string>
    <string name="start_stream">Start Stream</string>
    <string name="stop_stream">Stop Stream</string>
    <string name="bluetooth_route">Bluetooth</string>
    <string name="hearing_aid_route">Hearing Aid</string>
    <string name="speaker_route">Speaker</string>
    <string name="active_route">Active Route: %1$s</string>
    <string name="microphone_permission_rationale">We need microphone access to stream audio.</string>
    <string name="bluetooth_permission_rationale">Bluetooth permissions let us route audio to your hearing aids.</string>
    <string name="call_permission_rationale">Grant call management permission so the system can expose hearing aid routing.</string>
    <string name="call_active">Call streaming active</string>
    <string name="call_idle">Stream idle</string>
    <string name="request_route">Request Route</string>
    <string name="route_pending">Route change pending…</string>
    <string name="call_notification_channel_name">Hearing stream activity</string>
    <string name="call_notification_channel_desc">Status of the managed VoIP audio stream.</string>
    <string name="call_streaming_failed_in_use">Streaming failed because another stream is already active.</string>
    <string name="call_streaming_failed_no_sender">Streaming failed: no streaming service available.</string>
    <string name="call_streaming_failed_generic">Streaming could not start.</string>
    <string name="call_activation_failed">Telecom could not activate the stream.</string>
    <string name="unsupported_version">Requires Android 14 or newer.</string>
    <string name="call_connecting">Connecting…</string>
    <string name="call_ending">Tearing down stream…</string>
    <string name="call_error_prefix">Stream error: %1$s</string>
    <string name="grant_permissions">Grant required permissions</string>
</resources>


================================================
File: app/src/main/res/values/themes.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="Theme.HearingAidStreamer" parent="Theme.Material3.DayNight.NoActionBar">
        <item name="android:windowTranslucentStatus">true</item>
    </style>
</resources>


