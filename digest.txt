Directory structure:
└── steto/
    ├── build.gradle.kts
    ├── gradle.properties
    ├── settings.gradle.kts
    └── app/
        ├── build.gradle.kts
        ├── proguard-rules.pro
        └── src/
            └── main/
                ├── AndroidManifest.xml
                ├── java/
                │   └── com/
                │       └── example/
                │           └── hearingaidstreamer/
                │               ├── audio/
                │               │   └── LoopbackAudioEngine.kt
                │               ├── permissions/
                │               │   └── PermissionUtils.kt
                │               ├── telecom/
                │               │   ├── CallLifecycleState.kt
                │               │   ├── CallLifecycleStateExtensions.kt
                │               │   ├── CallRouteFormatter.kt
                │               │   ├── HearingAidConnectionService.kt
                │               │   └── TelecomCallManager.kt
                │               └── ui/
                │                   ├── MainActivity.kt
                │                   └── MainViewModel.kt
                └── res/
                    ├── drawable/
                    │   └── ic_launcher_foreground.xml
                    ├── mipmap-anydpi/
                    │   └── ic_launcher.xml
                    ├── mipmap-anydpi-v26/
                    │   └── ic_launcher.xml
                    └── values/
                        ├── colors.xml
                        ├── colors_launcher.xml
                        ├── strings.xml
                        └── themes.xml

================================================
File: build.gradle.kts
================================================
plugins {
    id("com.android.application") version "8.4.2" apply false
    id("org.jetbrains.kotlin.android") version "1.9.24" apply false
}


================================================
File: gradle.properties
================================================
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
android.useAndroidX=true
android.enableJetifier=true
kotlin.code.style=official


================================================
File: settings.gradle.kts
================================================
import org.gradle.api.initialization.resolve.RepositoriesMode

pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "HearingAidStreamer"
include(":app")


================================================
File: app/build.gradle.kts
================================================

plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.example.hearingaidstreamer"
    compileSdk = 34

    defaultConfig {
        applicationId = "com.example.hearingaidstreamer"
        minSdk = 31
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary = true
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_17
        targetCompatibility = JavaVersion.VERSION_17
    }
    kotlinOptions {
        jvmTarget = "17"
    }
    buildFeatures {
        compose = true
    }
    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.14"
    }
    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }
}

dependencies {
    val composeBom = platform("androidx.compose:compose-bom:2024.06.00")
    implementation(composeBom)
    androidTestImplementation(composeBom)

    implementation("androidx.core:core-ktx:1.13.1")
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.7.0")
    implementation("androidx.activity:activity-compose:1.9.0")
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0")
    implementation("androidx.lifecycle:lifecycle-runtime-compose:2.7.0")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.8.1")

    implementation("androidx.core.telecom:telecom:1.0.0-beta01")

    testImplementation("junit:junit:4.13.2")
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
    androidTestImplementation("androidx.compose.ui:ui-test-junit4")
    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")
}


================================================
File: app/proguard-rules.pro
================================================
# Add project specific ProGuard rules here.
# By default, the flags in this file are appended to flags specified
# in ${sdk.dir}/tools/proguard/proguard-android.txt


================================================
File: app/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.MODIFY_AUDIO_SETTINGS" />
    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
    <uses-permission android:name="android.permission.BLUETOOTH_SCAN" android:usesPermissionFlags="neverForLocation" />
    <uses-permission android:name="android.permission.BLUETOOTH_ADVERTISE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_MICROPHONE" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />
    <uses-permission android:name="android.permission.MANAGE_OWN_CALLS" />
    <uses-permission android:name="android.permission.CALL_PHONE" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:supportsRtl="true"
        android:theme="@style/Theme.HearingAidStreamer">

        <activity
            android:name="com.example.hearingaidstreamer.ui.MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <service
            android:name="com.example.hearingaidstreamer.telecom.HearingAidConnectionService"
            android:exported="true"
            android:permission="android.permission.BIND_TELECOM_CONNECTION_SERVICE" />

    </application>

</manifest>


================================================
File: app/src/main/java/com/example/hearingaidstreamer/audio/LoopbackAudioEngine.kt
================================================
package com.example.hearingaidstreamer.audio

import android.media.AudioAttributes
import android.media.AudioFormat
import android.media.AudioRecord
import android.media.AudioTrack
import android.media.MediaRecorder
import kotlinx.coroutines.CoroutineDispatcher
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.cancelAndJoin
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

/**
 * Captures raw microphone audio and replays it through the voice communication stream.
 * This keeps the audio routing managed by the Telecom stack (e.g. hearing aids) intact.
 */
class LoopbackAudioEngine(
    private val dispatcher: CoroutineDispatcher = Dispatchers.IO
) {
    private var job: Job? = null
    private var audioRecord: AudioRecord? = null
    private var audioTrack: AudioTrack? = null

    fun start(scope: CoroutineScope, sampleRate: Int = 16_000) {
        if (job != null) return

        val channelConfig = AudioFormat.CHANNEL_IN_MONO
        val audioFormat = AudioFormat.ENCODING_PCM_16BIT
        val minBufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat)
        val bufferSize = minBufferSize.coerceAtLeast(sampleRate)

        val record = AudioRecord.Builder()
            .setAudioSource(MediaRecorder.AudioSource.VOICE_COMMUNICATION)
            .setAudioFormat(
                AudioFormat.Builder()
                    .setSampleRate(sampleRate)
                    .setEncoding(audioFormat)
                    .setChannelMask(channelConfig)
                    .build()
            )
            .setBufferSizeInBytes(bufferSize * 2)
            .build()

        val track = AudioTrack.Builder()
            .setAudioAttributes(
                AudioAttributes.Builder()
                    .setUsage(AudioAttributes.USAGE_VOICE_COMMUNICATION)
                    .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                    .build()
            )
            .setAudioFormat(
                AudioFormat.Builder()
                    .setSampleRate(sampleRate)
                    .setEncoding(audioFormat)
                    .setChannelMask(AudioFormat.CHANNEL_OUT_MONO)
                    .build()
            )
            .setBufferSizeInBytes(bufferSize * 2)
            .setTransferMode(AudioTrack.MODE_STREAM)
            .build()

        track.play()
        record.startRecording()

        audioRecord = record
        audioTrack = track

        job = scope.launch(dispatcher) {
            val buffer = ShortArray(bufferSize)
            while (isActive) {
                val read = record.read(buffer, 0, buffer.size)
                if (read > 0) {
                    track.write(buffer, 0, read)
                }
            }
        }
    }

    suspend fun stop() {
        job?.let { existing ->
            withContext(dispatcher) {
                existing.cancelAndJoin()
            }
        }
        job = null

        audioRecord?.apply {
            try {
                stop()
            } catch (_: IllegalStateException) {
            }
            release()
        }
        audioTrack?.apply {
            try {
                stop()
            } catch (_: IllegalStateException) {
            }
            release()
        }
        audioRecord = null
        audioTrack = null
    }
}


================================================
File: app/src/main/java/com/example/hearingaidstreamer/permissions/PermissionUtils.kt
================================================
package com.example.hearingaidstreamer.permissions

import android.content.Context
import android.content.pm.PackageManager
import androidx.core.content.ContextCompat

fun missingPermissions(context: Context, permissions: Collection<String>): List<String> {
    return permissions.filter { permission ->
        ContextCompat.checkSelfPermission(context, permission) != PackageManager.PERMISSION_GRANTED
    }
}


================================================
File: app/src/main/java/com/example/hearingaidstreamer/telecom/CallLifecycleState.kt
================================================
package com.example.hearingaidstreamer.telecom

sealed interface CallLifecycleState {
    data object Idle : CallLifecycleState
    data object Connecting : CallLifecycleState
    data object Active : CallLifecycleState
    data object Ending : CallLifecycleState
    data class Error(val message: String) : CallLifecycleState
}


================================================
File: app/src/main/java/com/example/hearingaidstreamer/telecom/CallLifecycleStateExtensions.kt
================================================
package com.example.hearingaidstreamer.telecom

import android.content.Context
import com.example.hearingaidstreamer.R

fun CallLifecycleState.readableStatus(context: Context): String = when (this) {
    CallLifecycleState.Idle -> context.getString(R.string.call_idle)
    CallLifecycleState.Connecting -> context.getString(R.string.call_connecting)
    CallLifecycleState.Active -> context.getString(R.string.call_active)
    CallLifecycleState.Ending -> context.getString(R.string.call_ending)
    is CallLifecycleState.Error -> context.getString(R.string.call_error_prefix, message)
}


================================================
File: app/src/main/java/com/example/hearingaidstreamer/telecom/CallRouteFormatter.kt
================================================
package com.example.hearingaidstreamer.telecom

import android.content.Context
import android.telecom.CallEndpoint
import com.example.hearingaidstreamer.R

object CallRouteFormatter {
    fun label(context: Context, endpoint: CallEndpoint): String {
        return when (endpoint.endpointType) {
            CallEndpoint.TYPE_BLUETOOTH -> context.getString(R.string.bluetooth_route)
            CallEndpoint.TYPE_SPEAKER -> context.getString(R.string.speaker_route)
            CallEndpoint.TYPE_STREAMING -> context.getString(R.string.hearing_aid_route)
            else -> endpoint.endpointName.toString()
        }
    }
}


================================================
File: app/src/main/java/com/example/hearingaidstreamer/telecom/HearingAidConnectionService.kt
================================================
package com.example.hearingaidstreamer.telecom

import android.telecom.Connection
import android.telecom.ConnectionRequest
import android.telecom.ConnectionService
import android.telecom.DisconnectCause
import android.telecom.PhoneAccountHandle

/**
 * Minimal self-managed connection service required so that Telecom accepts the self-managed
 * phone account registration. All media handling is coordinated via [TelecomCallManager].
 */
class HearingAidConnectionService : ConnectionService() {

    override fun onCreateOutgoingConnection(
        connectionManagerPhoneAccount: PhoneAccountHandle?,
        request: ConnectionRequest
    ): Connection {
        return createStubConnection()
    }

    override fun onCreateIncomingConnection(
        connectionManagerPhoneAccount: PhoneAccountHandle?,
        request: ConnectionRequest
    ): Connection {
        return createStubConnection()
    }

    private fun createStubConnection(): Connection {
        return Connection().apply {
            setConnectionCapabilities(Connection.CAPABILITY_SELF_MANAGED)
            setDisconnected(DisconnectCause(DisconnectCause.LOCAL))
            destroy()
        }
    }
}


================================================
File: app/src/main/java/com/example/hearingaidstreamer/telecom/TelecomCallManager.kt
================================================
package com.example.hearingaidstreamer.telecom

import android.content.ComponentName
import android.content.Context
import android.net.Uri
import android.os.Build
import android.os.OutcomeReceiver
import android.telecom.CallAttributes
import android.telecom.CallControl
import android.telecom.CallControlCallback
import android.telecom.CallEndpoint
import android.telecom.CallEventCallback
import android.telecom.CallException
import android.telecom.CallStreamingService
import android.telecom.DisconnectCause
import android.telecom.PhoneAccount
import android.telecom.PhoneAccountHandle
import android.telecom.TelecomManager
import android.util.Log
import androidx.annotation.RequiresApi
import androidx.core.content.ContextCompat
import com.example.hearingaidstreamer.R
import com.example.hearingaidstreamer.audio.LoopbackAudioEngine
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.util.concurrent.Executor
import java.util.function.Consumer

/**
 * Coordinates a self-managed VoIP call using the platform Telecom APIs (Android 14+).
 */
@RequiresApi(Build.VERSION_CODES.UPSIDE_DOWN_CAKE)
class TelecomCallManager(
    private val context: Context,
    private val scope: CoroutineScope,
    private val audioEngine: LoopbackAudioEngine
) {

    private val telecomManager: TelecomManager =
        context.getSystemService(TelecomManager::class.java)
            ?: throw IllegalStateException("TelecomManager not available")

    private val phoneAccountHandle = PhoneAccountHandle(
        ComponentName(context, HearingAidConnectionService::class.java),
        PHONE_ACCOUNT_ID
    )

    private val mainExecutor: Executor = ContextCompat.getMainExecutor(context)

    private val _state = MutableStateFlow<CallLifecycleState>(CallLifecycleState.Idle)
    val state: StateFlow<CallLifecycleState> = _state

    private val _availableEndpoints = MutableStateFlow<List<CallEndpoint>>(emptyList())
    val availableEndpoints: StateFlow<List<CallEndpoint>> = _availableEndpoints

    private val _activeEndpoint = MutableStateFlow<CallEndpoint?>(null)
    val activeEndpoint: StateFlow<CallEndpoint?> = _activeEndpoint

    private var callControl: CallControl? = null

    private val controlCallback = object : CallControlCallback {
        override fun onSetActive(wasCompleted: Consumer<Boolean>) {
            wasCompleted.accept(true)
        }

        override fun onSetInactive(wasCompleted: Consumer<Boolean>) {
            scope.launch { audioEngine.stop() }
            _state.value = CallLifecycleState.Ending
            wasCompleted.accept(true)
        }

        override fun onAnswer(videoState: Int, wasCompleted: Consumer<Boolean>) {
            wasCompleted.accept(true)
        }

        override fun onDisconnect(disconnectCause: DisconnectCause, wasCompleted: Consumer<Boolean>) {
            scope.launch {
                stopCallInternal(disconnectCause)
                wasCompleted.accept(true)
            }
        }

        override fun onCallStreamingStarted(wasCompleted: Consumer<Boolean>) {
            scope.launch {
                audioEngine.start(scope)
                _state.value = CallLifecycleState.Active
                wasCompleted.accept(true)
            }
        }
    }

    private val eventCallback = object : CallEventCallback {
        override fun onCallEndpointChanged(newCallEndpoint: CallEndpoint) {
            _activeEndpoint.value = newCallEndpoint
        }

        override fun onAvailableCallEndpointsChanged(availableEndpoints: List<CallEndpoint>) {
            _availableEndpoints.value = availableEndpoints
        }

        override fun onMuteStateChanged(isMuted: Boolean) {
            // Hook for future mute UI; no-op for now.
        }

        override fun onCallStreamingFailed(reason: Int) {
            val message = when (reason) {
                CallStreamingService.STREAMING_FAILED_ALREADY_STREAMING ->
                    context.getString(R.string.call_streaming_failed_in_use)
                CallStreamingService.STREAMING_FAILED_NO_SENDER,
                CallStreamingService.STREAMING_FAILED_SENDER_BINDING_ERROR ->
                    context.getString(R.string.call_streaming_failed_no_sender)
                else -> context.getString(R.string.call_streaming_failed_generic)
            }
            _state.value = CallLifecycleState.Error(message)
        }

        override fun onEvent(event: String, extras: android.os.Bundle) {
            // Reserved for companion surfaces (car, wearable, etc.)
        }
    }

    init {
        ensurePhoneAccountRegistered()
    }

    fun startCall() {
        if (callControl != null) return
        _state.value = CallLifecycleState.Connecting

        val handle = Uri.fromParts("voip", "hearing_stream", null)
        val callAttributes = CallAttributes.Builder(
            phoneAccountHandle,
            CallAttributes.DIRECTION_OUTGOING,
            context.getString(R.string.app_name),
            handle
        )
            .setCallType(CallAttributes.AUDIO_CALL)
            .setCallCapabilities(CallAttributes.SUPPORTS_SET_INACTIVE or CallAttributes.SUPPORTS_STREAM)
            .build()

        telecomManager.addCall(
            callAttributes,
            mainExecutor,
            object : OutcomeReceiver<CallControl, CallException> {
                override fun onResult(result: CallControl) {
                    callControl = result
                    requestActiveAndStreaming(result)
                }

                override fun onError(error: CallException) {
                    _state.value = CallLifecycleState.Error(error.message ?: "Call setup failed")
                }
            },
            controlCallback,
            eventCallback
        )
    }

    fun stopCall() {
        val control = callControl ?: return
        val disconnectCause = DisconnectCause(DisconnectCause.LOCAL)
        control.disconnect(disconnectCause, mainExecutor, outcomeReceiver("disconnect"))
        scope.launch { stopCallInternal(disconnectCause) }
    }

    fun requestEndpointChange(endpoint: CallEndpoint) {
        val control = callControl ?: return
        control.requestCallEndpointChange(endpoint, mainExecutor, outcomeReceiver("endpoint"))
    }

    private fun requestActiveAndStreaming(control: CallControl) {
        control.setActive(mainExecutor, outcomeReceiver("setActive") { success ->
            if (success) {
                control.startCallStreaming(mainExecutor, outcomeReceiver("startStreaming") { streaming ->
                    if (!streaming) {
                        _state.value = CallLifecycleState.Error(context.getString(R.string.call_streaming_failed_generic))
                    }
                })
            } else {
                _state.value = CallLifecycleState.Error(context.getString(R.string.call_activation_failed))
            }
        })
    }

    private suspend fun stopCallInternal(disconnectCause: DisconnectCause) {
        audioEngine.stop()
        withContext(Dispatchers.Main) {
            _state.value = CallLifecycleState.Idle
            _availableEndpoints.value = emptyList()
            _activeEndpoint.value = null
            callControl = null
        }
    }

    private fun outcomeReceiver(
        tag: String,
        onResult: ((Boolean) -> Unit)? = null
    ): OutcomeReceiver<Void, CallException> {
        return object : OutcomeReceiver<Void, CallException> {
            override fun onResult(result: Void?) {
                onResult?.invoke(true)
            }

            override fun onError(error: CallException) {
                Log.e(TAG, "$tag failed", error)
                onResult?.invoke(false)
            }
        }
    }

    private fun ensurePhoneAccountRegistered() {
        val existing = telecomManager.getPhoneAccount(phoneAccountHandle)
        if (existing != null) return

        val phoneAccount = PhoneAccount.Builder(
            phoneAccountHandle,
            context.getString(R.string.app_name)
        )
            .setCapabilities(PhoneAccount.CAPABILITY_SELF_MANAGED)
            .setShortDescription(context.getString(R.string.app_name))
            .setSupportedUriSchemes(listOf("voip", PhoneAccount.SCHEME_SIP))
            .build()

        telecomManager.registerPhoneAccount(phoneAccount)
    }

    companion object {
        private const val TAG = "TelecomCallManager"
        private const val PHONE_ACCOUNT_ID = "hearing_aid_streamer_account"
    }
}


================================================
File: app/src/main/java/com/example/hearingaidstreamer/ui/MainActivity.kt
================================================
package com.example.hearingaidstreamer.ui

import android.Manifest
import android.os.Build
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.Button
import androidx.compose.material3.Card
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.FilterChip
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.saveable.rememberSaveable
import androidx.compose.runtime.setValue
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.example.hearingaidstreamer.permissions.missingPermissions
import com.example.hearingaidstreamer.telecom.CallLifecycleState
import com.example.hearingaidstreamer.telecom.CallRouteFormatter
import com.example.hearingaidstreamer.telecom.readableStatus
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.collect

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MaterialTheme {
                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {
                    val context = LocalContext.current
                    val viewModel: MainViewModel = viewModel(factory = MainViewModel.factory(context))
                    val callState by viewModel.callState.collectAsStateWithLifecycleCompat()
                    val endpoints by viewModel.availableEndpoints.collectAsStateWithLifecycleCompat()
                    val activeEndpoint by viewModel.activeEndpoint.collectAsStateWithLifecycleCompat()

                    val requiredPermissions = remember {
                        buildList {
                            add(Manifest.permission.RECORD_AUDIO)
                            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
                                add(Manifest.permission.BLUETOOTH_CONNECT)
                                add(Manifest.permission.BLUETOOTH_SCAN)
                            }
                            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
                                add(Manifest.permission.MANAGE_OWN_CALLS)
                            }
                        }
                    }

                    var missing by rememberSaveable { mutableStateOf(missingPermissions(context, requiredPermissions)) }

                    LaunchedEffect(requiredPermissions) {
                        missing = missingPermissions(context, requiredPermissions)
                    }

                    val permissionLauncher = androidx.activity.compose.rememberLauncherForActivityResult(
                        contract = ActivityResultContracts.RequestMultiplePermissions()
                    ) { result ->
                        val stillMissing = missingPermissions(context, requiredPermissions)
                        missing = stillMissing
                        val granted = result.values.all { it }
                        if (granted && stillMissing.isEmpty()) {
                            viewModel.startCall()
                        }
                    }

                    MainScreen(
                        state = callState,
                        endpoints = endpoints,
                        activeEndpoint = activeEndpoint,
                        missingPermissions = missing,
                        onRequestPermissions = {
                            permissionLauncher.launch(requiredPermissions.toTypedArray())
                        },
                        onStart = { viewModel.startCall() },
                        onStop = { viewModel.stopCall() },
                        onSelectEndpoint = { endpoint -> viewModel.requestEndpoint(endpoint) }
                    )
                }
            }
        }
    }
}

@Composable
private fun MainScreen(
    state: CallLifecycleState,
    endpoints: List<android.telecom.CallEndpoint>,
    activeEndpoint: android.telecom.CallEndpoint?,
    missingPermissions: List<String>,
    onRequestPermissions: () -> Unit,
    onStart: () -> Unit,
    onStop: () -> Unit,
    onSelectEndpoint: (android.telecom.CallEndpoint) -> Unit
) {
    val context = LocalContext.current
    val isActive = state is CallLifecycleState.Active
    val isConnecting = state is CallLifecycleState.Connecting

    Scaffold { paddingValues ->
        Column(
            modifier = Modifier
                .padding(paddingValues)
                .padding(24.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Text(
                text = state.readableStatus(context),
                style = MaterialTheme.typography.headlineSmall,
                fontWeight = FontWeight.SemiBold
            )

            when (state) {
                is CallLifecycleState.Connecting -> {
                    CircularProgressIndicator()
                }

                is CallLifecycleState.Error -> {
                    Text(
                        text = state.message,
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.error
                    )
                }

                else -> Unit
            }

            if (missingPermissions.isNotEmpty()) {
                Card(modifier = Modifier.padding(vertical = 8.dp)) {
                    Column(modifier = Modifier.padding(16.dp), verticalArrangement = Arrangement.spacedBy(8.dp)) {
                        Text(
                            text = context.getString(com.example.hearingaidstreamer.R.string.microphone_permission_rationale),
                            style = MaterialTheme.typography.bodyMedium
                        )
                        Button(onClick = onRequestPermissions) {
                            Text(text = context.getString(com.example.hearingaidstreamer.R.string.grant_permissions))
                        }
                    }
                }
            } else {
                val canStart = state is CallLifecycleState.Idle || state is CallLifecycleState.Error
                Button(
                    onClick = onStart,
                    enabled = canStart && missingPermissions.isEmpty()
                ) {
                    Text(text = context.getString(com.example.hearingaidstreamer.R.string.start_stream))
                }
                val canStop = state is CallLifecycleState.Active || state is CallLifecycleState.Connecting || state is CallLifecycleState.Ending
                Button(
                    onClick = onStop,
                    enabled = canStop
                ) {
                    Text(text = context.getString(com.example.hearingaidstreamer.R.string.stop_stream))
                }

                if (endpoints.isNotEmpty()) {
                    Text(
                        text = context.getString(com.example.hearingaidstreamer.R.string.request_route),
                        style = MaterialTheme.typography.titleMedium
                    )

                    LazyRow(horizontalArrangement = Arrangement.spacedBy(12.dp)) {
                        items(endpoints, key = { it.identifier }) { endpoint ->
                            val selected = activeEndpoint?.identifier == endpoint.identifier
                            FilterChip(
                                selected = selected,
                                onClick = { onSelectEndpoint(endpoint) },
                                label = { Text(CallRouteFormatter.label(context, endpoint)) }
                            )
                        }
                    }

                    activeEndpoint?.let { endpoint ->
                        Spacer(modifier = Modifier.height(8.dp))
                        Text(
                            text = context.getString(
                                com.example.hearingaidstreamer.R.string.active_route,
                                CallRouteFormatter.label(context, endpoint)
                            ),
                            style = MaterialTheme.typography.bodyMedium
                        )
                    }
                }
            }
        }
    }
}

@Composable
private fun <T> StateFlow<T>.collectAsStateWithLifecycleCompat(): androidx.compose.runtime.State<T> {
    val stateFlow = this
    val initialValue = remember(stateFlow) { stateFlow.value }
    val state = remember { mutableStateOf(initialValue) }
    LaunchedEffect(stateFlow) {
        stateFlow.collect { value -> state.value = value }
    }
    return state
}


================================================
File: app/src/main/java/com/example/hearingaidstreamer/ui/MainViewModel.kt
================================================
package com.example.hearingaidstreamer.ui

import android.content.Context
import android.os.Build
import android.telecom.CallEndpoint
import androidx.lifecycle.ViewModel
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.viewModelScope
import com.example.hearingaidstreamer.R
import com.example.hearingaidstreamer.audio.LoopbackAudioEngine
import com.example.hearingaidstreamer.telecom.CallLifecycleState
import com.example.hearingaidstreamer.telecom.TelecomCallManager
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow

class MainViewModel(private val appContext: Context) : ViewModel() {

    private val audioEngine = LoopbackAudioEngine()

    private val callManager: TelecomCallManager? = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
        TelecomCallManager(appContext, viewModelScope, audioEngine)
    } else {
        null
    }

    private val unsupportedState = MutableStateFlow<CallLifecycleState>(
        CallLifecycleState.Error(appContext.getString(R.string.unsupported_version))
    )

    private val emptyEndpoints = MutableStateFlow<List<CallEndpoint>>(emptyList())
    private val nullEndpoint = MutableStateFlow<CallEndpoint?>(null)

    val callState: StateFlow<CallLifecycleState> = callManager?.state ?: unsupportedState
    val availableEndpoints: StateFlow<List<CallEndpoint>> = callManager?.availableEndpoints ?: emptyEndpoints
    val activeEndpoint: StateFlow<CallEndpoint?> = callManager?.activeEndpoint ?: nullEndpoint

    fun startCall() {
        callManager?.startCall()
    }

    fun stopCall() {
        callManager?.stopCall()
    }

    fun requestEndpoint(endpoint: CallEndpoint) {
        callManager?.requestEndpointChange(endpoint)
    }

    override fun onCleared() {
        callManager?.stopCall()
        super.onCleared()
    }

    companion object {
        fun factory(appContext: Context): ViewModelProvider.Factory = object : ViewModelProvider.Factory {
            override fun <T : ViewModel> create(modelClass: Class<T>): T {
                require(modelClass.isAssignableFrom(MainViewModel::class.java))
                return MainViewModel(appContext.applicationContext) as T
            }
        }
    }
}


================================================
File: app/src/main/res/drawable/ic_launcher_foreground.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    <group android:translationX="27" android:translationY="27">
        <path
            android:fillColor="#FFFFFF"
            android:pathData="M27,54c-6.075,0 -11,-4.925 -11,-11s4.925,-11 11,-11 11,4.925 11,11 -4.925,11 -11,11z"/>
        <path
            android:fillColor="#1E88E5"
            android:pathData="M27,45c-1.657,0 -3,-1.343 -3,-3s1.343,-3 3,-3 3,1.343 3,3 -1.343,3 -3,3z"/>
        <path
            android:fillColor="#1E88E5"
            android:pathData="M13,25h28v6h-28z"/>
        <path
            android:fillColor="#FFFFFF"
            android:pathData="M13,28c0,-8.837 7.163,-16 16,-16s16,7.163 16,16h-6c0,-5.523 -4.477,-10 -10,-10s-10,4.477 -10,10z"/>
    </group>
</vector>


================================================
File: app/src/main/res/mipmap-anydpi/ic_launcher.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>


================================================
File: app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background" />
    <foreground android:drawable="@drawable/ic_launcher_foreground" />
</adaptive-icon>


================================================
File: app/src/main/res/values/colors.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="md_theme_light_primary">#6750A4</color>
    <color name="md_theme_light_onPrimary">#FFFFFF</color>
    <color name="md_theme_light_secondary">#625B71</color>
    <color name="md_theme_light_onSecondary">#FFFFFF</color>
</resources>


================================================
File: app/src/main/res/values/colors_launcher.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_background">#1E88E5</color>
</resources>


================================================
File: app/src/main/res/values/strings.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">Hearing Aid Streamer</string>
    <string name="start_stream">Start Stream</string>
    <string name="stop_stream">Stop Stream</string>
    <string name="bluetooth_route">Bluetooth</string>
    <string name="hearing_aid_route">Hearing Aid</string>
    <string name="speaker_route">Speaker</string>
    <string name="active_route">Active Route: %1$s</string>
    <string name="microphone_permission_rationale">We need microphone access to stream audio.</string>
    <string name="bluetooth_permission_rationale">Bluetooth permissions let us route audio to your hearing aids.</string>
    <string name="call_permission_rationale">Grant call management permission so the system can expose hearing aid routing.</string>
    <string name="call_active">Call streaming active</string>
    <string name="call_idle">Stream idle</string>
    <string name="request_route">Request Route</string>
    <string name="route_pending">Route change pending…</string>
    <string name="call_notification_channel_name">Hearing stream activity</string>
    <string name="call_notification_channel_desc">Status of the managed VoIP audio stream.</string>
    <string name="call_streaming_failed_in_use">Streaming failed because another stream is already active.</string>
    <string name="call_streaming_failed_no_sender">Streaming failed: no streaming service available.</string>
    <string name="call_streaming_failed_generic">Streaming could not start.</string>
    <string name="call_activation_failed">Telecom could not activate the stream.</string>
    <string name="unsupported_version">Requires Android 14 or newer.</string>
    <string name="call_connecting">Connecting…</string>
    <string name="call_ending">Tearing down stream…</string>
    <string name="call_error_prefix">Stream error: %1$s</string>
    <string name="grant_permissions">Grant required permissions</string>
</resources>


================================================
File: app/src/main/res/values/themes.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="Theme.HearingAidStreamer" parent="Theme.Material3.DayNight.NoActionBar">
        <item name="android:windowTranslucentStatus">true</item>
    </style>
</resources>


